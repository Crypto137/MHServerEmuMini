// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Gazillion {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class FrontendProtocol {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Gazillion_LoginDataPB__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.LoginDataPB, global::Gazillion.LoginDataPB.Builder> internal__static_Gazillion_LoginDataPB__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Gazillion_InitialClientHandshake__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.InitialClientHandshake, global::Gazillion.InitialClientHandshake.Builder> internal__static_Gazillion_InitialClientHandshake__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Gazillion_ClientCredentials__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.ClientCredentials, global::Gazillion.ClientCredentials.Builder> internal__static_Gazillion_ClientCredentials__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Gazillion_LoginQueueStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.LoginQueueStatus, global::Gazillion.LoginQueueStatus.Builder> internal__static_Gazillion_LoginQueueStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Gazillion_SessionEncryptionChanged__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.SessionEncryptionChanged, global::Gazillion.SessionEncryptionChanged.Builder> internal__static_Gazillion_SessionEncryptionChanged__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Gazillion_EncryptedTrafficHeader__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Gazillion.EncryptedTrafficHeader, global::Gazillion.EncryptedTrafficHeader.Builder> internal__static_Gazillion_EncryptedTrafficHeader__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static FrontendProtocol() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZGcm9udGVuZFByb3RvY29sLnByb3RvEglHYXppbGxpb24aFFB1YlN1YlBy", 
            "b3RvY29sLnByb3RvIoEDCgtMb2dpbkRhdGFQQhIiCgxlbWFpbEFkZHJlc3MY", 
            "ASACKAlSDGVtYWlsQWRkcmVzcxIaCghwYXNzd29yZBgCIAIoCVIIcGFzc3dv", 
            "cmQSGAoHdmVyc2lvbhgDIAEoCVIHdmVyc2lvbhIiCgxkYnNlcnZlcm5hbWUY", 
            "BCABKAlSDGRic2VydmVybmFtZRIUCgV0b2tlbhgFIAEoCVIFdG9rZW4SMgoU", 
            "bG9naW5Bc0Fub3RoZXJQbGF5ZXIYBiABKAhSFGxvZ2luQXNBbm90aGVyUGxh", 
            "eWVyEjoKGG5vUGVyc2lzdGVuY2VUaGlzU2Vzc2lvbhgHIAEoCFIYbm9QZXJz", 
            "aXN0ZW5jZVRoaXNTZXNzaW9uEiQKDWxvZ2luQXNQbGF5ZXIYCCABKAlSDWxv", 
            "Z2luQXNQbGF5ZXISKgoQY2xpZW50RG93bmxvYWRlchgJIAEoCVIQY2xpZW50", 
            "RG93bmxvYWRlchIcCgltYWNoaW5lSWQYCiABKAlSCW1hY2hpbmVJZCK1AQoW", 
            "SW5pdGlhbENsaWVudEhhbmRzaGFrZRJdCg9wcm90b2NvbFZlcnNpb24YASAC", 
            "KA4yIi5HYXppbGxpb24uRnJvbnRlbmRQcm90b2NvbFZlcnNpb246D0NVUlJF", 
            "TlRfVkVSU0lPTlIPcHJvdG9jb2xWZXJzaW9uEjwKCnNlcnZlclR5cGUYAiAC", 
            "KA4yHC5HYXppbGxpb24uUHViU3ViU2VydmVyVHlwZXNSCnNlcnZlclR5cGUi", 
            "aQoRQ2xpZW50Q3JlZGVudGlhbHMSHAoJc2Vzc2lvbmlkGAEgAigEUglzZXNz", 
            "aW9uaWQSDgoCaXYYAiACKAxSAml2EiYKDmVuY3J5cHRlZFRva2VuGAMgAigM", 
            "Ug5lbmNyeXB0ZWRUb2tlbiJqChBMb2dpblF1ZXVlU3RhdHVzEiAKC3BsYWNl", 
            "SW5MaW5lGAEgAigEUgtwbGFjZUluTGluZRI0ChVudW1iZXJPZlBsYXllcnNJ", 
            "bkxpbmUYAiACKARSFW51bWJlck9mUGxheWVyc0luTGluZSKBAQoYU2Vzc2lv", 
            "bkVuY3J5cHRpb25DaGFuZ2VkEi8KEXJhbmRvbU51bWJlckluZGV4GAEgAigN", 
            "OgExUhFyYW5kb21OdW1iZXJJbmRleBI0ChVlbmNyeXB0ZWRSYW5kb21OdW1i", 
            "ZXIYAiACKAxSFWVuY3J5cHRlZFJhbmRvbU51bWJlciJyChZFbmNyeXB0ZWRU", 
            "cmFmZmljSGVhZGVyEiwKEXJhbmRvbU51bWJlckluZGV4GAEgAigNUhFyYW5k", 
            "b21OdW1iZXJJbmRleBIqChBlbmNyeXB0ZWRUcmFmZmljGAIgAigMUhBlbmNy", 
            "eXB0ZWRUcmFmZmljKi4KF0Zyb250ZW5kUHJvdG9jb2xWZXJzaW9uEhMKD0NV", 
          "UlJFTlRfVkVSU0lPThAB"));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Gazillion_LoginDataPB__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Gazillion_LoginDataPB__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.LoginDataPB, global::Gazillion.LoginDataPB.Builder>(internal__static_Gazillion_LoginDataPB__Descriptor,
                new string[] { "EmailAddress", "Password", "Version", "Dbservername", "Token", "LoginAsAnotherPlayer", "NoPersistenceThisSession", "LoginAsPlayer", "ClientDownloader", "MachineId", });
        internal__static_Gazillion_InitialClientHandshake__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Gazillion_InitialClientHandshake__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.InitialClientHandshake, global::Gazillion.InitialClientHandshake.Builder>(internal__static_Gazillion_InitialClientHandshake__Descriptor,
                new string[] { "ProtocolVersion", "ServerType", });
        internal__static_Gazillion_ClientCredentials__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Gazillion_ClientCredentials__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.ClientCredentials, global::Gazillion.ClientCredentials.Builder>(internal__static_Gazillion_ClientCredentials__Descriptor,
                new string[] { "Sessionid", "Iv", "EncryptedToken", });
        internal__static_Gazillion_LoginQueueStatus__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Gazillion_LoginQueueStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.LoginQueueStatus, global::Gazillion.LoginQueueStatus.Builder>(internal__static_Gazillion_LoginQueueStatus__Descriptor,
                new string[] { "PlaceInLine", "NumberOfPlayersInLine", });
        internal__static_Gazillion_SessionEncryptionChanged__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Gazillion_SessionEncryptionChanged__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.SessionEncryptionChanged, global::Gazillion.SessionEncryptionChanged.Builder>(internal__static_Gazillion_SessionEncryptionChanged__Descriptor,
                new string[] { "RandomNumberIndex", "EncryptedRandomNumber", });
        internal__static_Gazillion_EncryptedTrafficHeader__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Gazillion_EncryptedTrafficHeader__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Gazillion.EncryptedTrafficHeader, global::Gazillion.EncryptedTrafficHeader.Builder>(internal__static_Gazillion_EncryptedTrafficHeader__Descriptor,
                new string[] { "RandomNumberIndex", "EncryptedTraffic", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        global::Gazillion.PubSubProtocol.RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Gazillion.PubSubProtocol.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  public enum FrontendProtocolVersion {
    CURRENT_VERSION = 1,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LoginDataPB : pb::GeneratedMessage<LoginDataPB, LoginDataPB.Builder> {
    private LoginDataPB() { }
    private static readonly LoginDataPB defaultInstance = new LoginDataPB().MakeReadOnly();
    private static readonly string[] _loginDataPBFieldNames = new string[] { "clientDownloader", "dbservername", "emailAddress", "loginAsAnotherPlayer", "loginAsPlayer", "machineId", "noPersistenceThisSession", "password", "token", "version" };
    private static readonly uint[] _loginDataPBFieldTags = new uint[] { 74, 34, 10, 48, 66, 82, 56, 18, 42, 26 };
    public static LoginDataPB DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LoginDataPB DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LoginDataPB ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_LoginDataPB__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LoginDataPB, LoginDataPB.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_LoginDataPB__FieldAccessorTable; }
    }
    
    public const int EmailAddressFieldNumber = 1;
    private bool hasEmailAddress;
    private string emailAddress_ = "";
    public bool HasEmailAddress {
      get { return hasEmailAddress; }
    }
    public string EmailAddress {
      get { return emailAddress_; }
    }
    
    public const int PasswordFieldNumber = 2;
    private bool hasPassword;
    private string password_ = "";
    public bool HasPassword {
      get { return hasPassword; }
    }
    public string Password {
      get { return password_; }
    }
    
    public const int VersionFieldNumber = 3;
    private bool hasVersion;
    private string version_ = "";
    public bool HasVersion {
      get { return hasVersion; }
    }
    public string Version {
      get { return version_; }
    }
    
    public const int DbservernameFieldNumber = 4;
    private bool hasDbservername;
    private string dbservername_ = "";
    public bool HasDbservername {
      get { return hasDbservername; }
    }
    public string Dbservername {
      get { return dbservername_; }
    }
    
    public const int TokenFieldNumber = 5;
    private bool hasToken;
    private string token_ = "";
    public bool HasToken {
      get { return hasToken; }
    }
    public string Token {
      get { return token_; }
    }
    
    public const int LoginAsAnotherPlayerFieldNumber = 6;
    private bool hasLoginAsAnotherPlayer;
    private bool loginAsAnotherPlayer_;
    public bool HasLoginAsAnotherPlayer {
      get { return hasLoginAsAnotherPlayer; }
    }
    public bool LoginAsAnotherPlayer {
      get { return loginAsAnotherPlayer_; }
    }
    
    public const int NoPersistenceThisSessionFieldNumber = 7;
    private bool hasNoPersistenceThisSession;
    private bool noPersistenceThisSession_;
    public bool HasNoPersistenceThisSession {
      get { return hasNoPersistenceThisSession; }
    }
    public bool NoPersistenceThisSession {
      get { return noPersistenceThisSession_; }
    }
    
    public const int LoginAsPlayerFieldNumber = 8;
    private bool hasLoginAsPlayer;
    private string loginAsPlayer_ = "";
    public bool HasLoginAsPlayer {
      get { return hasLoginAsPlayer; }
    }
    public string LoginAsPlayer {
      get { return loginAsPlayer_; }
    }
    
    public const int ClientDownloaderFieldNumber = 9;
    private bool hasClientDownloader;
    private string clientDownloader_ = "";
    public bool HasClientDownloader {
      get { return hasClientDownloader; }
    }
    public string ClientDownloader {
      get { return clientDownloader_; }
    }
    
    public const int MachineIdFieldNumber = 10;
    private bool hasMachineId;
    private string machineId_ = "";
    public bool HasMachineId {
      get { return hasMachineId; }
    }
    public string MachineId {
      get { return machineId_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEmailAddress) return false;
        if (!hasPassword) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _loginDataPBFieldNames;
      if (hasEmailAddress) {
        output.WriteString(1, field_names[2], EmailAddress);
      }
      if (hasPassword) {
        output.WriteString(2, field_names[7], Password);
      }
      if (hasVersion) {
        output.WriteString(3, field_names[9], Version);
      }
      if (hasDbservername) {
        output.WriteString(4, field_names[1], Dbservername);
      }
      if (hasToken) {
        output.WriteString(5, field_names[8], Token);
      }
      if (hasLoginAsAnotherPlayer) {
        output.WriteBool(6, field_names[3], LoginAsAnotherPlayer);
      }
      if (hasNoPersistenceThisSession) {
        output.WriteBool(7, field_names[6], NoPersistenceThisSession);
      }
      if (hasLoginAsPlayer) {
        output.WriteString(8, field_names[4], LoginAsPlayer);
      }
      if (hasClientDownloader) {
        output.WriteString(9, field_names[0], ClientDownloader);
      }
      if (hasMachineId) {
        output.WriteString(10, field_names[5], MachineId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEmailAddress) {
        size += pb::CodedOutputStream.ComputeStringSize(1, EmailAddress);
      }
      if (hasPassword) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Password);
      }
      if (hasVersion) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Version);
      }
      if (hasDbservername) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Dbservername);
      }
      if (hasToken) {
        size += pb::CodedOutputStream.ComputeStringSize(5, Token);
      }
      if (hasLoginAsAnotherPlayer) {
        size += pb::CodedOutputStream.ComputeBoolSize(6, LoginAsAnotherPlayer);
      }
      if (hasNoPersistenceThisSession) {
        size += pb::CodedOutputStream.ComputeBoolSize(7, NoPersistenceThisSession);
      }
      if (hasLoginAsPlayer) {
        size += pb::CodedOutputStream.ComputeStringSize(8, LoginAsPlayer);
      }
      if (hasClientDownloader) {
        size += pb::CodedOutputStream.ComputeStringSize(9, ClientDownloader);
      }
      if (hasMachineId) {
        size += pb::CodedOutputStream.ComputeStringSize(10, MachineId);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static LoginDataPB ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LoginDataPB ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LoginDataPB ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LoginDataPB ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LoginDataPB ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LoginDataPB MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LoginDataPB prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<LoginDataPB, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LoginDataPB cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LoginDataPB result;
      
      private LoginDataPB PrepareBuilder() {
        if (resultIsReadOnly) {
          LoginDataPB original = result;
          result = new LoginDataPB();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LoginDataPB MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.LoginDataPB.Descriptor; }
      }
      
      public override LoginDataPB DefaultInstanceForType {
        get { return global::Gazillion.LoginDataPB.DefaultInstance; }
      }
      
      public override LoginDataPB BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LoginDataPB) {
          return MergeFrom((LoginDataPB) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LoginDataPB other) {
        if (other == global::Gazillion.LoginDataPB.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEmailAddress) {
          EmailAddress = other.EmailAddress;
        }
        if (other.HasPassword) {
          Password = other.Password;
        }
        if (other.HasVersion) {
          Version = other.Version;
        }
        if (other.HasDbservername) {
          Dbservername = other.Dbservername;
        }
        if (other.HasToken) {
          Token = other.Token;
        }
        if (other.HasLoginAsAnotherPlayer) {
          LoginAsAnotherPlayer = other.LoginAsAnotherPlayer;
        }
        if (other.HasNoPersistenceThisSession) {
          NoPersistenceThisSession = other.NoPersistenceThisSession;
        }
        if (other.HasLoginAsPlayer) {
          LoginAsPlayer = other.LoginAsPlayer;
        }
        if (other.HasClientDownloader) {
          ClientDownloader = other.ClientDownloader;
        }
        if (other.HasMachineId) {
          MachineId = other.MachineId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_loginDataPBFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _loginDataPBFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasEmailAddress = input.ReadString(ref result.emailAddress_);
              break;
            }
            case 18: {
              result.hasPassword = input.ReadString(ref result.password_);
              break;
            }
            case 26: {
              result.hasVersion = input.ReadString(ref result.version_);
              break;
            }
            case 34: {
              result.hasDbservername = input.ReadString(ref result.dbservername_);
              break;
            }
            case 42: {
              result.hasToken = input.ReadString(ref result.token_);
              break;
            }
            case 48: {
              result.hasLoginAsAnotherPlayer = input.ReadBool(ref result.loginAsAnotherPlayer_);
              break;
            }
            case 56: {
              result.hasNoPersistenceThisSession = input.ReadBool(ref result.noPersistenceThisSession_);
              break;
            }
            case 66: {
              result.hasLoginAsPlayer = input.ReadString(ref result.loginAsPlayer_);
              break;
            }
            case 74: {
              result.hasClientDownloader = input.ReadString(ref result.clientDownloader_);
              break;
            }
            case 82: {
              result.hasMachineId = input.ReadString(ref result.machineId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEmailAddress {
        get { return result.hasEmailAddress; }
      }
      public string EmailAddress {
        get { return result.EmailAddress; }
        set { SetEmailAddress(value); }
      }
      public Builder SetEmailAddress(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEmailAddress = true;
        result.emailAddress_ = value;
        return this;
      }
      public Builder ClearEmailAddress() {
        PrepareBuilder();
        result.hasEmailAddress = false;
        result.emailAddress_ = "";
        return this;
      }
      
      public bool HasPassword {
        get { return result.hasPassword; }
      }
      public string Password {
        get { return result.Password; }
        set { SetPassword(value); }
      }
      public Builder SetPassword(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPassword = true;
        result.password_ = value;
        return this;
      }
      public Builder ClearPassword() {
        PrepareBuilder();
        result.hasPassword = false;
        result.password_ = "";
        return this;
      }
      
      public bool HasVersion {
        get { return result.hasVersion; }
      }
      public string Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = "";
        return this;
      }
      
      public bool HasDbservername {
        get { return result.hasDbservername; }
      }
      public string Dbservername {
        get { return result.Dbservername; }
        set { SetDbservername(value); }
      }
      public Builder SetDbservername(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDbservername = true;
        result.dbservername_ = value;
        return this;
      }
      public Builder ClearDbservername() {
        PrepareBuilder();
        result.hasDbservername = false;
        result.dbservername_ = "";
        return this;
      }
      
      public bool HasToken {
        get { return result.hasToken; }
      }
      public string Token {
        get { return result.Token; }
        set { SetToken(value); }
      }
      public Builder SetToken(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasToken = true;
        result.token_ = value;
        return this;
      }
      public Builder ClearToken() {
        PrepareBuilder();
        result.hasToken = false;
        result.token_ = "";
        return this;
      }
      
      public bool HasLoginAsAnotherPlayer {
        get { return result.hasLoginAsAnotherPlayer; }
      }
      public bool LoginAsAnotherPlayer {
        get { return result.LoginAsAnotherPlayer; }
        set { SetLoginAsAnotherPlayer(value); }
      }
      public Builder SetLoginAsAnotherPlayer(bool value) {
        PrepareBuilder();
        result.hasLoginAsAnotherPlayer = true;
        result.loginAsAnotherPlayer_ = value;
        return this;
      }
      public Builder ClearLoginAsAnotherPlayer() {
        PrepareBuilder();
        result.hasLoginAsAnotherPlayer = false;
        result.loginAsAnotherPlayer_ = false;
        return this;
      }
      
      public bool HasNoPersistenceThisSession {
        get { return result.hasNoPersistenceThisSession; }
      }
      public bool NoPersistenceThisSession {
        get { return result.NoPersistenceThisSession; }
        set { SetNoPersistenceThisSession(value); }
      }
      public Builder SetNoPersistenceThisSession(bool value) {
        PrepareBuilder();
        result.hasNoPersistenceThisSession = true;
        result.noPersistenceThisSession_ = value;
        return this;
      }
      public Builder ClearNoPersistenceThisSession() {
        PrepareBuilder();
        result.hasNoPersistenceThisSession = false;
        result.noPersistenceThisSession_ = false;
        return this;
      }
      
      public bool HasLoginAsPlayer {
        get { return result.hasLoginAsPlayer; }
      }
      public string LoginAsPlayer {
        get { return result.LoginAsPlayer; }
        set { SetLoginAsPlayer(value); }
      }
      public Builder SetLoginAsPlayer(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLoginAsPlayer = true;
        result.loginAsPlayer_ = value;
        return this;
      }
      public Builder ClearLoginAsPlayer() {
        PrepareBuilder();
        result.hasLoginAsPlayer = false;
        result.loginAsPlayer_ = "";
        return this;
      }
      
      public bool HasClientDownloader {
        get { return result.hasClientDownloader; }
      }
      public string ClientDownloader {
        get { return result.ClientDownloader; }
        set { SetClientDownloader(value); }
      }
      public Builder SetClientDownloader(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasClientDownloader = true;
        result.clientDownloader_ = value;
        return this;
      }
      public Builder ClearClientDownloader() {
        PrepareBuilder();
        result.hasClientDownloader = false;
        result.clientDownloader_ = "";
        return this;
      }
      
      public bool HasMachineId {
        get { return result.hasMachineId; }
      }
      public string MachineId {
        get { return result.MachineId; }
        set { SetMachineId(value); }
      }
      public Builder SetMachineId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMachineId = true;
        result.machineId_ = value;
        return this;
      }
      public Builder ClearMachineId() {
        PrepareBuilder();
        result.hasMachineId = false;
        result.machineId_ = "";
        return this;
      }
    }
    static LoginDataPB() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class InitialClientHandshake : pb::GeneratedMessage<InitialClientHandshake, InitialClientHandshake.Builder> {
    private InitialClientHandshake() { }
    private static readonly InitialClientHandshake defaultInstance = new InitialClientHandshake().MakeReadOnly();
    private static readonly string[] _initialClientHandshakeFieldNames = new string[] { "protocolVersion", "serverType" };
    private static readonly uint[] _initialClientHandshakeFieldTags = new uint[] { 8, 16 };
    public static InitialClientHandshake DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override InitialClientHandshake DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override InitialClientHandshake ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_InitialClientHandshake__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<InitialClientHandshake, InitialClientHandshake.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_InitialClientHandshake__FieldAccessorTable; }
    }
    
    public const int ProtocolVersionFieldNumber = 1;
    private bool hasProtocolVersion;
    private global::Gazillion.FrontendProtocolVersion protocolVersion_ = global::Gazillion.FrontendProtocolVersion.CURRENT_VERSION;
    public bool HasProtocolVersion {
      get { return hasProtocolVersion; }
    }
    public global::Gazillion.FrontendProtocolVersion ProtocolVersion {
      get { return protocolVersion_; }
    }
    
    public const int ServerTypeFieldNumber = 2;
    private bool hasServerType;
    private global::Gazillion.PubSubServerTypes serverType_ = global::Gazillion.PubSubServerTypes.FRONTEND_SERVER;
    public bool HasServerType {
      get { return hasServerType; }
    }
    public global::Gazillion.PubSubServerTypes ServerType {
      get { return serverType_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasProtocolVersion) return false;
        if (!hasServerType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _initialClientHandshakeFieldNames;
      if (hasProtocolVersion) {
        output.WriteEnum(1, field_names[0], (int) ProtocolVersion, ProtocolVersion);
      }
      if (hasServerType) {
        output.WriteEnum(2, field_names[1], (int) ServerType, ServerType);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasProtocolVersion) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) ProtocolVersion);
      }
      if (hasServerType) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) ServerType);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static InitialClientHandshake ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static InitialClientHandshake ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static InitialClientHandshake ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InitialClientHandshake ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private InitialClientHandshake MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(InitialClientHandshake prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<InitialClientHandshake, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(InitialClientHandshake cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private InitialClientHandshake result;
      
      private InitialClientHandshake PrepareBuilder() {
        if (resultIsReadOnly) {
          InitialClientHandshake original = result;
          result = new InitialClientHandshake();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override InitialClientHandshake MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.InitialClientHandshake.Descriptor; }
      }
      
      public override InitialClientHandshake DefaultInstanceForType {
        get { return global::Gazillion.InitialClientHandshake.DefaultInstance; }
      }
      
      public override InitialClientHandshake BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is InitialClientHandshake) {
          return MergeFrom((InitialClientHandshake) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(InitialClientHandshake other) {
        if (other == global::Gazillion.InitialClientHandshake.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProtocolVersion) {
          ProtocolVersion = other.ProtocolVersion;
        }
        if (other.HasServerType) {
          ServerType = other.ServerType;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_initialClientHandshakeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _initialClientHandshakeFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.protocolVersion_, out unknown)) {
                result.hasProtocolVersion = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.serverType_, out unknown)) {
                result.hasServerType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProtocolVersion {
       get { return result.hasProtocolVersion; }
      }
      public global::Gazillion.FrontendProtocolVersion ProtocolVersion {
        get { return result.ProtocolVersion; }
        set { SetProtocolVersion(value); }
      }
      public Builder SetProtocolVersion(global::Gazillion.FrontendProtocolVersion value) {
        PrepareBuilder();
        result.hasProtocolVersion = true;
        result.protocolVersion_ = value;
        return this;
      }
      public Builder ClearProtocolVersion() {
        PrepareBuilder();
        result.hasProtocolVersion = false;
        result.protocolVersion_ = global::Gazillion.FrontendProtocolVersion.CURRENT_VERSION;
        return this;
      }
      
      public bool HasServerType {
       get { return result.hasServerType; }
      }
      public global::Gazillion.PubSubServerTypes ServerType {
        get { return result.ServerType; }
        set { SetServerType(value); }
      }
      public Builder SetServerType(global::Gazillion.PubSubServerTypes value) {
        PrepareBuilder();
        result.hasServerType = true;
        result.serverType_ = value;
        return this;
      }
      public Builder ClearServerType() {
        PrepareBuilder();
        result.hasServerType = false;
        result.serverType_ = global::Gazillion.PubSubServerTypes.FRONTEND_SERVER;
        return this;
      }
    }
    static InitialClientHandshake() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ClientCredentials : pb::GeneratedMessage<ClientCredentials, ClientCredentials.Builder> {
    private ClientCredentials() { }
    private static readonly ClientCredentials defaultInstance = new ClientCredentials().MakeReadOnly();
    private static readonly string[] _clientCredentialsFieldNames = new string[] { "encryptedToken", "iv", "sessionid" };
    private static readonly uint[] _clientCredentialsFieldTags = new uint[] { 26, 18, 8 };
    public static ClientCredentials DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ClientCredentials DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ClientCredentials ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_ClientCredentials__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ClientCredentials, ClientCredentials.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_ClientCredentials__FieldAccessorTable; }
    }
    
    public const int SessionidFieldNumber = 1;
    private bool hasSessionid;
    private ulong sessionid_;
    public bool HasSessionid {
      get { return hasSessionid; }
    }
    public ulong Sessionid {
      get { return sessionid_; }
    }
    
    public const int IvFieldNumber = 2;
    private bool hasIv;
    private pb::ByteString iv_ = pb::ByteString.Empty;
    public bool HasIv {
      get { return hasIv; }
    }
    public pb::ByteString Iv {
      get { return iv_; }
    }
    
    public const int EncryptedTokenFieldNumber = 3;
    private bool hasEncryptedToken;
    private pb::ByteString encryptedToken_ = pb::ByteString.Empty;
    public bool HasEncryptedToken {
      get { return hasEncryptedToken; }
    }
    public pb::ByteString EncryptedToken {
      get { return encryptedToken_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSessionid) return false;
        if (!hasIv) return false;
        if (!hasEncryptedToken) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _clientCredentialsFieldNames;
      if (hasSessionid) {
        output.WriteUInt64(1, field_names[2], Sessionid);
      }
      if (hasIv) {
        output.WriteBytes(2, field_names[1], Iv);
      }
      if (hasEncryptedToken) {
        output.WriteBytes(3, field_names[0], EncryptedToken);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSessionid) {
        size += pb::CodedOutputStream.ComputeUInt64Size(1, Sessionid);
      }
      if (hasIv) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, Iv);
      }
      if (hasEncryptedToken) {
        size += pb::CodedOutputStream.ComputeBytesSize(3, EncryptedToken);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static ClientCredentials ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ClientCredentials ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ClientCredentials ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ClientCredentials ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ClientCredentials ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ClientCredentials MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ClientCredentials prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ClientCredentials, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ClientCredentials cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ClientCredentials result;
      
      private ClientCredentials PrepareBuilder() {
        if (resultIsReadOnly) {
          ClientCredentials original = result;
          result = new ClientCredentials();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ClientCredentials MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.ClientCredentials.Descriptor; }
      }
      
      public override ClientCredentials DefaultInstanceForType {
        get { return global::Gazillion.ClientCredentials.DefaultInstance; }
      }
      
      public override ClientCredentials BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ClientCredentials) {
          return MergeFrom((ClientCredentials) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ClientCredentials other) {
        if (other == global::Gazillion.ClientCredentials.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSessionid) {
          Sessionid = other.Sessionid;
        }
        if (other.HasIv) {
          Iv = other.Iv;
        }
        if (other.HasEncryptedToken) {
          EncryptedToken = other.EncryptedToken;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_clientCredentialsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _clientCredentialsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSessionid = input.ReadUInt64(ref result.sessionid_);
              break;
            }
            case 18: {
              result.hasIv = input.ReadBytes(ref result.iv_);
              break;
            }
            case 26: {
              result.hasEncryptedToken = input.ReadBytes(ref result.encryptedToken_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSessionid {
        get { return result.hasSessionid; }
      }
      public ulong Sessionid {
        get { return result.Sessionid; }
        set { SetSessionid(value); }
      }
      public Builder SetSessionid(ulong value) {
        PrepareBuilder();
        result.hasSessionid = true;
        result.sessionid_ = value;
        return this;
      }
      public Builder ClearSessionid() {
        PrepareBuilder();
        result.hasSessionid = false;
        result.sessionid_ = 0UL;
        return this;
      }
      
      public bool HasIv {
        get { return result.hasIv; }
      }
      public pb::ByteString Iv {
        get { return result.Iv; }
        set { SetIv(value); }
      }
      public Builder SetIv(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasIv = true;
        result.iv_ = value;
        return this;
      }
      public Builder ClearIv() {
        PrepareBuilder();
        result.hasIv = false;
        result.iv_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasEncryptedToken {
        get { return result.hasEncryptedToken; }
      }
      public pb::ByteString EncryptedToken {
        get { return result.EncryptedToken; }
        set { SetEncryptedToken(value); }
      }
      public Builder SetEncryptedToken(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEncryptedToken = true;
        result.encryptedToken_ = value;
        return this;
      }
      public Builder ClearEncryptedToken() {
        PrepareBuilder();
        result.hasEncryptedToken = false;
        result.encryptedToken_ = pb::ByteString.Empty;
        return this;
      }
    }
    static ClientCredentials() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LoginQueueStatus : pb::GeneratedMessage<LoginQueueStatus, LoginQueueStatus.Builder> {
    private LoginQueueStatus() { }
    private static readonly LoginQueueStatus defaultInstance = new LoginQueueStatus().MakeReadOnly();
    private static readonly string[] _loginQueueStatusFieldNames = new string[] { "numberOfPlayersInLine", "placeInLine" };
    private static readonly uint[] _loginQueueStatusFieldTags = new uint[] { 16, 8 };
    public static LoginQueueStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LoginQueueStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LoginQueueStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_LoginQueueStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LoginQueueStatus, LoginQueueStatus.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_LoginQueueStatus__FieldAccessorTable; }
    }
    
    public const int PlaceInLineFieldNumber = 1;
    private bool hasPlaceInLine;
    private ulong placeInLine_;
    public bool HasPlaceInLine {
      get { return hasPlaceInLine; }
    }
    public ulong PlaceInLine {
      get { return placeInLine_; }
    }
    
    public const int NumberOfPlayersInLineFieldNumber = 2;
    private bool hasNumberOfPlayersInLine;
    private ulong numberOfPlayersInLine_;
    public bool HasNumberOfPlayersInLine {
      get { return hasNumberOfPlayersInLine; }
    }
    public ulong NumberOfPlayersInLine {
      get { return numberOfPlayersInLine_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPlaceInLine) return false;
        if (!hasNumberOfPlayersInLine) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _loginQueueStatusFieldNames;
      if (hasPlaceInLine) {
        output.WriteUInt64(1, field_names[1], PlaceInLine);
      }
      if (hasNumberOfPlayersInLine) {
        output.WriteUInt64(2, field_names[0], NumberOfPlayersInLine);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasPlaceInLine) {
        size += pb::CodedOutputStream.ComputeUInt64Size(1, PlaceInLine);
      }
      if (hasNumberOfPlayersInLine) {
        size += pb::CodedOutputStream.ComputeUInt64Size(2, NumberOfPlayersInLine);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static LoginQueueStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LoginQueueStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LoginQueueStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LoginQueueStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LoginQueueStatus MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LoginQueueStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<LoginQueueStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LoginQueueStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LoginQueueStatus result;
      
      private LoginQueueStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          LoginQueueStatus original = result;
          result = new LoginQueueStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LoginQueueStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.LoginQueueStatus.Descriptor; }
      }
      
      public override LoginQueueStatus DefaultInstanceForType {
        get { return global::Gazillion.LoginQueueStatus.DefaultInstance; }
      }
      
      public override LoginQueueStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LoginQueueStatus) {
          return MergeFrom((LoginQueueStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LoginQueueStatus other) {
        if (other == global::Gazillion.LoginQueueStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPlaceInLine) {
          PlaceInLine = other.PlaceInLine;
        }
        if (other.HasNumberOfPlayersInLine) {
          NumberOfPlayersInLine = other.NumberOfPlayersInLine;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_loginQueueStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _loginQueueStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasPlaceInLine = input.ReadUInt64(ref result.placeInLine_);
              break;
            }
            case 16: {
              result.hasNumberOfPlayersInLine = input.ReadUInt64(ref result.numberOfPlayersInLine_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPlaceInLine {
        get { return result.hasPlaceInLine; }
      }
      public ulong PlaceInLine {
        get { return result.PlaceInLine; }
        set { SetPlaceInLine(value); }
      }
      public Builder SetPlaceInLine(ulong value) {
        PrepareBuilder();
        result.hasPlaceInLine = true;
        result.placeInLine_ = value;
        return this;
      }
      public Builder ClearPlaceInLine() {
        PrepareBuilder();
        result.hasPlaceInLine = false;
        result.placeInLine_ = 0UL;
        return this;
      }
      
      public bool HasNumberOfPlayersInLine {
        get { return result.hasNumberOfPlayersInLine; }
      }
      public ulong NumberOfPlayersInLine {
        get { return result.NumberOfPlayersInLine; }
        set { SetNumberOfPlayersInLine(value); }
      }
      public Builder SetNumberOfPlayersInLine(ulong value) {
        PrepareBuilder();
        result.hasNumberOfPlayersInLine = true;
        result.numberOfPlayersInLine_ = value;
        return this;
      }
      public Builder ClearNumberOfPlayersInLine() {
        PrepareBuilder();
        result.hasNumberOfPlayersInLine = false;
        result.numberOfPlayersInLine_ = 0UL;
        return this;
      }
    }
    static LoginQueueStatus() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SessionEncryptionChanged : pb::GeneratedMessage<SessionEncryptionChanged, SessionEncryptionChanged.Builder> {
    private SessionEncryptionChanged() { }
    private static readonly SessionEncryptionChanged defaultInstance = new SessionEncryptionChanged().MakeReadOnly();
    private static readonly string[] _sessionEncryptionChangedFieldNames = new string[] { "encryptedRandomNumber", "randomNumberIndex" };
    private static readonly uint[] _sessionEncryptionChangedFieldTags = new uint[] { 18, 8 };
    public static SessionEncryptionChanged DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SessionEncryptionChanged DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SessionEncryptionChanged ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_SessionEncryptionChanged__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SessionEncryptionChanged, SessionEncryptionChanged.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_SessionEncryptionChanged__FieldAccessorTable; }
    }
    
    public const int RandomNumberIndexFieldNumber = 1;
    private bool hasRandomNumberIndex;
    private uint randomNumberIndex_ = 1;
    public bool HasRandomNumberIndex {
      get { return hasRandomNumberIndex; }
    }
    public uint RandomNumberIndex {
      get { return randomNumberIndex_; }
    }
    
    public const int EncryptedRandomNumberFieldNumber = 2;
    private bool hasEncryptedRandomNumber;
    private pb::ByteString encryptedRandomNumber_ = pb::ByteString.Empty;
    public bool HasEncryptedRandomNumber {
      get { return hasEncryptedRandomNumber; }
    }
    public pb::ByteString EncryptedRandomNumber {
      get { return encryptedRandomNumber_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRandomNumberIndex) return false;
        if (!hasEncryptedRandomNumber) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _sessionEncryptionChangedFieldNames;
      if (hasRandomNumberIndex) {
        output.WriteUInt32(1, field_names[1], RandomNumberIndex);
      }
      if (hasEncryptedRandomNumber) {
        output.WriteBytes(2, field_names[0], EncryptedRandomNumber);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRandomNumberIndex) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, RandomNumberIndex);
      }
      if (hasEncryptedRandomNumber) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, EncryptedRandomNumber);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static SessionEncryptionChanged ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SessionEncryptionChanged ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SessionEncryptionChanged ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SessionEncryptionChanged MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SessionEncryptionChanged prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SessionEncryptionChanged, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SessionEncryptionChanged cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SessionEncryptionChanged result;
      
      private SessionEncryptionChanged PrepareBuilder() {
        if (resultIsReadOnly) {
          SessionEncryptionChanged original = result;
          result = new SessionEncryptionChanged();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SessionEncryptionChanged MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.SessionEncryptionChanged.Descriptor; }
      }
      
      public override SessionEncryptionChanged DefaultInstanceForType {
        get { return global::Gazillion.SessionEncryptionChanged.DefaultInstance; }
      }
      
      public override SessionEncryptionChanged BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SessionEncryptionChanged) {
          return MergeFrom((SessionEncryptionChanged) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SessionEncryptionChanged other) {
        if (other == global::Gazillion.SessionEncryptionChanged.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRandomNumberIndex) {
          RandomNumberIndex = other.RandomNumberIndex;
        }
        if (other.HasEncryptedRandomNumber) {
          EncryptedRandomNumber = other.EncryptedRandomNumber;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_sessionEncryptionChangedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _sessionEncryptionChangedFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasRandomNumberIndex = input.ReadUInt32(ref result.randomNumberIndex_);
              break;
            }
            case 18: {
              result.hasEncryptedRandomNumber = input.ReadBytes(ref result.encryptedRandomNumber_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRandomNumberIndex {
        get { return result.hasRandomNumberIndex; }
      }
      public uint RandomNumberIndex {
        get { return result.RandomNumberIndex; }
        set { SetRandomNumberIndex(value); }
      }
      public Builder SetRandomNumberIndex(uint value) {
        PrepareBuilder();
        result.hasRandomNumberIndex = true;
        result.randomNumberIndex_ = value;
        return this;
      }
      public Builder ClearRandomNumberIndex() {
        PrepareBuilder();
        result.hasRandomNumberIndex = false;
        result.randomNumberIndex_ = 1;
        return this;
      }
      
      public bool HasEncryptedRandomNumber {
        get { return result.hasEncryptedRandomNumber; }
      }
      public pb::ByteString EncryptedRandomNumber {
        get { return result.EncryptedRandomNumber; }
        set { SetEncryptedRandomNumber(value); }
      }
      public Builder SetEncryptedRandomNumber(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEncryptedRandomNumber = true;
        result.encryptedRandomNumber_ = value;
        return this;
      }
      public Builder ClearEncryptedRandomNumber() {
        PrepareBuilder();
        result.hasEncryptedRandomNumber = false;
        result.encryptedRandomNumber_ = pb::ByteString.Empty;
        return this;
      }
    }
    static SessionEncryptionChanged() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EncryptedTrafficHeader : pb::GeneratedMessage<EncryptedTrafficHeader, EncryptedTrafficHeader.Builder> {
    private EncryptedTrafficHeader() { }
    private static readonly EncryptedTrafficHeader defaultInstance = new EncryptedTrafficHeader().MakeReadOnly();
    private static readonly string[] _encryptedTrafficHeaderFieldNames = new string[] { "encryptedTraffic", "randomNumberIndex" };
    private static readonly uint[] _encryptedTrafficHeaderFieldTags = new uint[] { 18, 8 };
    public static EncryptedTrafficHeader DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EncryptedTrafficHeader DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EncryptedTrafficHeader ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_EncryptedTrafficHeader__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EncryptedTrafficHeader, EncryptedTrafficHeader.Builder> InternalFieldAccessors {
      get { return global::Gazillion.FrontendProtocol.internal__static_Gazillion_EncryptedTrafficHeader__FieldAccessorTable; }
    }
    
    public const int RandomNumberIndexFieldNumber = 1;
    private bool hasRandomNumberIndex;
    private uint randomNumberIndex_;
    public bool HasRandomNumberIndex {
      get { return hasRandomNumberIndex; }
    }
    public uint RandomNumberIndex {
      get { return randomNumberIndex_; }
    }
    
    public const int EncryptedTrafficFieldNumber = 2;
    private bool hasEncryptedTraffic;
    private pb::ByteString encryptedTraffic_ = pb::ByteString.Empty;
    public bool HasEncryptedTraffic {
      get { return hasEncryptedTraffic; }
    }
    public pb::ByteString EncryptedTraffic {
      get { return encryptedTraffic_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRandomNumberIndex) return false;
        if (!hasEncryptedTraffic) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _encryptedTrafficHeaderFieldNames;
      if (hasRandomNumberIndex) {
        output.WriteUInt32(1, field_names[1], RandomNumberIndex);
      }
      if (hasEncryptedTraffic) {
        output.WriteBytes(2, field_names[0], EncryptedTraffic);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRandomNumberIndex) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, RandomNumberIndex);
      }
      if (hasEncryptedTraffic) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, EncryptedTraffic);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EncryptedTrafficHeader ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EncryptedTrafficHeader ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EncryptedTrafficHeader MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EncryptedTrafficHeader prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EncryptedTrafficHeader, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EncryptedTrafficHeader cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EncryptedTrafficHeader result;
      
      private EncryptedTrafficHeader PrepareBuilder() {
        if (resultIsReadOnly) {
          EncryptedTrafficHeader original = result;
          result = new EncryptedTrafficHeader();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EncryptedTrafficHeader MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Gazillion.EncryptedTrafficHeader.Descriptor; }
      }
      
      public override EncryptedTrafficHeader DefaultInstanceForType {
        get { return global::Gazillion.EncryptedTrafficHeader.DefaultInstance; }
      }
      
      public override EncryptedTrafficHeader BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EncryptedTrafficHeader) {
          return MergeFrom((EncryptedTrafficHeader) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EncryptedTrafficHeader other) {
        if (other == global::Gazillion.EncryptedTrafficHeader.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRandomNumberIndex) {
          RandomNumberIndex = other.RandomNumberIndex;
        }
        if (other.HasEncryptedTraffic) {
          EncryptedTraffic = other.EncryptedTraffic;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_encryptedTrafficHeaderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _encryptedTrafficHeaderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasRandomNumberIndex = input.ReadUInt32(ref result.randomNumberIndex_);
              break;
            }
            case 18: {
              result.hasEncryptedTraffic = input.ReadBytes(ref result.encryptedTraffic_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRandomNumberIndex {
        get { return result.hasRandomNumberIndex; }
      }
      public uint RandomNumberIndex {
        get { return result.RandomNumberIndex; }
        set { SetRandomNumberIndex(value); }
      }
      public Builder SetRandomNumberIndex(uint value) {
        PrepareBuilder();
        result.hasRandomNumberIndex = true;
        result.randomNumberIndex_ = value;
        return this;
      }
      public Builder ClearRandomNumberIndex() {
        PrepareBuilder();
        result.hasRandomNumberIndex = false;
        result.randomNumberIndex_ = 0;
        return this;
      }
      
      public bool HasEncryptedTraffic {
        get { return result.hasEncryptedTraffic; }
      }
      public pb::ByteString EncryptedTraffic {
        get { return result.EncryptedTraffic; }
        set { SetEncryptedTraffic(value); }
      }
      public Builder SetEncryptedTraffic(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEncryptedTraffic = true;
        result.encryptedTraffic_ = value;
        return this;
      }
      public Builder ClearEncryptedTraffic() {
        PrepareBuilder();
        result.hasEncryptedTraffic = false;
        result.encryptedTraffic_ = pb::ByteString.Empty;
        return this;
      }
    }
    static EncryptedTrafficHeader() {
      object.ReferenceEquals(global::Gazillion.FrontendProtocol.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
